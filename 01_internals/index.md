---
layout: post
title: Под капотом у Hello World.
highlight: true
---

В этом уроке мы на примере простейшего Android приложения, созданного в [предыдущем уроке](../01_hello_world), подробно изучим устройство проекта, его сборку, попробуем базовые инструменты разработки и отладки, которые пригодядтся в дальнейшем.

## Устройство проекта

В [прошлом уроке](../01_hello_world/) мы уже сделали краткий обзор структуры проекта, но тогда мы больше внимания уделили файлам с исходным кодом. Сейчас мы подробнее рассмотрим файлы, о которых в прошлый раз упоминули лишь вскользь.

### Build скрипты

Стандартная система сборки Android приложений основана на Gradle (https://gradle.org/) -- опенсорнсом инструменте для сборки общего назначения -- и плагине для Gradle, который знает, как собирать Android проекты. Вам не нужно устанавливать эти инструменты, потому что система сборки устроена так, что всё необходимое скачивается и устанавливается во время сборки  (удобно, но требует подключения к Интернету во время сборки). Однако, если по каким-то причинам, вы хотите использовать предустановленный дистрибутив Gradle, вы можете указать путь к нему в настройках Android Studio (*Use local Gradle distribution* в разделе *Build, Execution, Deployment / Gradle* настроек).

<img src="img/0600_gradle_settings.png" width="800px"/>

Стандартная конфигурация системы сборки включает использование Gradle Wrapper. Для этого в проекте есть специальные файлы:
```
<project_dir>/
	gradlew
    gradlew.bat
    gradle/wrapper/
    	gradle-wrapper.jar
        gradle-wrapper.properties
```

**gradlew** и **gradlew.bat** -- это скрипты для запуска Gradle Wrapper для Linux подобных систем и для Windows. Gradle Wrapper является Java приложением и находится в файле **gradle-wrapper.jar**. Очевидно, что для запуска сборки необходима установленная Java -- она входит в комплект установки Android Studio.

Файл **gradle-wrapper.properties** содержит самые общие параметры запуска Gradle, и, наверно, единственный параметр, который вам может понадобиться менять -- это версия Gradle в параметре `distributionUrl`. Если вы долго работаете над одним проектом, то за время работы может появиться более новая версия Gradle, и тогда, чтобы перейти на неё, вам придется подредактировать `gradle-wrapper.properties`.

После старта Gradle Wrapper при необходимости скачивает необходимую версию Gradle и запускает его, чтобы тот занялся уже непосредственно сборкой проекта. За сборку проекта отвечают следующие файлы:

```
<project_dir>/
	build.gradle
    settings.gradle
    gradle.properties
    local.properties
    app/
    	build.gradle
```

Начнем с **local.properties** -- в этом файле определены свойства, значения которых имеют смысл только на вашей машине, на которой вы запускаете сборку. Это, прежде всего, `sdk.dir` -- путь к установленному Android SDK. Файл `local.properties` должен быть свой у каждого разработчика, который работает над проектом, и его не надо коммитить в общий репозиторий. Если в вашем проекте нет других настроек, зависящих от машины, на которой запускается сборка, то проще определить переменную окружения `ANDROID_HOME` -- тогда файл `local.properties` вообще не будет нужен.

Файл **gradle.properties** содержит настройки, которые используется при сборке проекта. В новом проект там обычно определено свойство `org.gradle.jvmargs`, в котором прописан параметр `-Xmx` для запуска JVM. Сборка Android приложений требует много памяти, особенно, если проект большой (а большим проект может стать очень быстро), поэтому, когда заметите, что сборка стала сильно тормозить, проверьте -- не упирается ли она в память, и не надо ли увеличить `-Xmx`. Впрочем, оптимизация и ускорение сборки Android проектов это отдельная сложная тема, и одним параметром `-Xmx` вопрос не ограничивается.

Файл **settings.gradle** обычно определяет структуру проекта. В новом проекте приложения типа Hello World, содержимое этого файла выглядит так:
```
include ':app'
```
Здесь указан единственный модуль, из которого состоит проект. Если модулей больше -- они перечисляются через запятую: `include ':app', ':module1', 'module2'`.

Файл **build.gradle** в корне проекта уже содержит какое-то "мясо" -- здесь описывается сборка всего проекта на уровне, общем для всех модулей. Файл начинается со следующего блока:
```
buildscript {
    repositories {
        google()
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:3.3.0'
    }
}
```
Главное здесь -- объявление зависимости на Android Gradle плагин: `com.android.tools.build:gradle:3.3.0`, который непосредственно отвечает за сборку Android приложения. Вам может понадобиться подредактировать здесь его версию, если во время работы над проектом вышла новая версия плагина с каким-то новыми фичами или оптимизациями, и вы хотите её использовать. Репозитории google и jcenter, прописанные в этом блоке нужны для поиска там указанной версии плагина. Обратите внимание -- эти репозитории относятся только к блоку `buildscript`, то есть к системе сборки, но они не относятся к зависимостям вашего приложения, которые вы используете в коде.

Репозитории для поиска зависимостей приложения определены в следующем блоке:
```
allprojects {
    repositories {
        google()
        jcenter()
    }
}
```
Слово `allproject` говорит о том, что этот блок применяется ко всем модулям проекта, и вам не надо прописывать эти репозитории в каждом отдельном модуле.

Файл **app/build.gradle**, который лежит в папке модуля приложения app, описывает сборку этого модуля, а так как этот модуль содержит само приложение, в этом билд скрипте содержится всё самое интересное. Первая его строчка
```
apply plugin: 'com.android.application'
```
определяет, что перед нами модуль, содержащий Android приложение, и для его сборки будет использовать Android Gradle плагин. Другой возможный вариант -- это `com.android.library` для библиотечных модулей. Обычно Android проект содержит один модуль приложения и любое количество библиотечных модулей.

Затем идет блок `android`, в котором определены основные параметры приложения:
```
android {
    compileSdkVersion 28
    defaultConfig {
        applicationId "ru.ok.technopolis.helloworld"
        minSdkVersion 19
        targetSdkVersion 28
        versionCode 1
        versionName "1.0"
        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
}
```

**applicationId** -- это ID, по которому приложения идентифицируются в операционной системе Android и в магазинах приложений вроде Google Play. Этот ID мы указывали при создании проекта в Android Studio.

**versionName** -- это версия приложения, как её будут видеть пользователи, например, на странице приложения в Google Play или в системных настройках Android устройства в информации о приложении. Значение `versionName` может быть любым, но обычно это числа, разделенные точками: `1.0`, `1.1`, `2.0`, `2.0.1` -- это традиционная *семантическая* система нумерации версий. Иногда в **versionName** кодируют дату релиза приложения: `19.1.22` (22 января 2019 года). Могут присутствовать буквы, например: `5.1-alpha`, `19.2.13-debug` и пр. Вообще, `versionName` используется исключительно как текст для отображения пользователям.

**versionCode** -- это тоже версия приложения, но, в отличие от `versionName`, имеет значение типа `int` и используется для алгоритмической обработки и в бизнес-логике приложения. Допустимые значения: положительные целые числа, обязательно возрастающие с каждой версией приложения. Если вы публикуете приложение в магазине приложений, то в каждом следующем обновлении должно быть большее значение `versionCode`.

Далее идут три похожих свойства: **compileSdkVersion**, **minSdkVersion** и **targetSdkVersion** -- это всё про версии Android.

### Разные версии Android...

**compileSdkVersion** определяет версию Android, которая будет использоваться для того, чтобы скомпилировать код приложения. Для каждой версии Android в Android SDK есть свой файл *android.jar*, содержащий все классы и методы, имеющиеся в этой версии Android. Когда Java код приложения компилируется при помощи javac, в classpath добавляется этот android.jar и таким образом коду приложения становятся доступны все API из этой версии Android. При просмотре Android API Reference обратите внимание -- для каждого класса или метода есть указание, в какой версии Android этот класс или метод появился. Например, метод `View.setTranslationZ(float)` появился в API Level 21:
<img src="img/0610_added_in_api_level.png" width="800px"/>
Если метод появился в API Level 21, это значит, что для того, чтобы использовать его в коде приложения, нужно установить значение compileSdkVersion 21 или выше.

**minSdkVersion** определяет минимальную версию Android, на которой приложение может быть установлено и запущено. Этот параметр вы указывали при создании приложения в Android Studio. С точки зрения простоты разработки, чем выще minSdkVersion, тем лучше -- тогда разработчикам не придется заботиться о том, чтобы приложение правильно работало на старых версиях Android (обычно приложения лучше работают на более новых версиях Android -- там меньше багов, меньше технических ограничений, чаще более мощные процессоры с большим объемом памяти и т.п.). Однако, увеличивая minSdkVersion, вы ограничиваете количество устройств, на которых будет работать приложение и уменьшаете его потенциальную аудиторию -- а это плохо для бизнеса, в котором используется приложение. Поэтому приходится искать баланс между стоимостью поддeржки старых версий Android и потенциальной выгодой для бизнеса от расширения аудитории.

**targetSdkVersion** -- это версия Android, для которой "предназначено" ваше приложение. Это значит, в общих чертах, что в процессе разработки вы продумывали работу приложения на этой версии Android, тестировали на ней, и гарантируете, что на targetSdkVersion версии Android ваше приложение работает хорошо, без багов -- так, как задумывалось. Это нужно для того, чтобы в будущих версиях Android (которые еще не вышли, и про которые мы ничего не можем знать во время разработки приложения) наше приложение продолжало работать так, как мы задумывали, несмотря на то, что технологии могли измениться, поведение операционной системы могло измениться и, вообще говоря, по меркам будущих версий Android, наше сегодняшнее приложение может считаться написанным неправильно. Когда Android запускает приложение со старым targetSdkVesion, он может принять дополнительные меры для того, чтобы приложение работало правильно -- запустить его в особом *compatibility* режиме. Указывая targetSdkVersion, мы фиксируем набор правил и поведение операционной системы, которые действительны для этой версии Android, и таким образом мы можем больше не заботиться о поддержке более новых версий Android. Впрочем, Google может не дать нам расслабиться -- иногда в магазине приложений Google Play появляются ограничения на использование старых версий в **targetSdkVersion**. Например, c 1 авгутста 2018 года в Google Play нельзя публиковать новые приложения с targetSdkVersion меньше 26 (а с 1 ноября 2018 -- и обновления старых приложений). Это заставило всех разработчиков оптимизировать их приложения под Android 8.0 (самое сложное -- пришлось переписать работу фоновых сервисов).

### Build Types

В дефолтном сгенерированном build скрипте есть раздел **buildTypes**:
```
buildTypes {
    release {
        minifyEnabled false
        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
    }
}
```
В Android проекте есть два стандартных типа сборки: release и debug.

По умолчанию в Android Studio используется тип сборки **debug**. Эта сборка предназначена для того, чтобы отлаживать её -- в ней может делаться меньше оптимизаций, добавляться больше отладочной информации, могут включаться специальные режимы работы, удобные для тестирования, логирование и пр. Debug сборки *не предназначены для пользователей*, и их нельзя публиковать и распространять через магазины приложений. Внутри `buildTypes` дефолтного build скрипта блок *debug* отсутствует -- просто потому, что для *debug* сборки используются все значения по умолчанию.

**release** сборка, наоборот, предназначена для пользователей. Она максимально оптимизирована, из неё удаляется всё лишнее, её нельзя отлаживать при помощи дебаггера. Кроме того, release сборка подписывается сертификатом разработчика для удостоверения её происхождения и обеспечения целостности (чтобы злоумышленники не могли распространять свои зловреды под видом популярных приложений). Настройки *minifyEnabled* и *proguardFiles* относятся к процессу минификации: при сборке релизной версии приложения, её код проходит стадию минификации -- лишний неиспользуемый код удаляется, Java имена сокращаются. Это позволяет уменьшить размер кода и немного ускорить его загрузку, но сильно усложняет отладку.

## Сборка проекта

После того, как вы собрали приложение в Android Studio, в проекте появляется папка `app/build` (если бы было несколько модулей, то в каждом модуле появилась бы папка `build`). В ней содержатся результаты сборки и промежуточные файлы.

### APK файл

Собранный **APK файл** приложения находится в `app/build/outputs/apk/debug/app-debug.apk` (для дебажной сборки) -- именно этот файл устанавливается на устройство, когда вы запускаете приложение из Android Studio. Его можно даже открыть и посмотреть его содержимое:
<img src="img/0620_apk_content.png" width="1200px"/>
Внутри APK файла можно найти:
- **AndroidManifest.xml** -- манифест приложения, по которому операционная система узнает о структуре приложения.
- **classes.dex** -- исходный код, скомпилированный в специальны Dalvik byte code и упакованный в DEX (Dalvik EXecutable) файл
- **resources.arsc** -- значения всех ресурсов приложения, упакованные в один файл
- **res** -- папка с более сложными ресурсами, которые хранятся в отдельных файлах (картинки, файлы верстки)
- **META-INF** -- папка со служебной информацией, в первую очередь -- с подписями всех файлов.

Все XML файлы, которые можно увидеть внутри APK файла при помощи Android Studio, на самом деле хранятся в оптимизированном бинарном формате, который занмает меньше места и быстрее парсится в рантайме.

*Примечание: если вы собираете и запускаете приложение в Android Studio, но не находите APK файл в папке `app/build/outputs/apk/debug/` -- отключите **Instant Run** в настройках Android Studio.*

Внутри `app/build` особый интерес представляет папка **generatedJava** -- здесь находятся исходники (Java файлы), которые были автоматически сгенерированы во время сборки приложения. Мы эти исходники не писали, но мы можем их использовать в своем коде, и часто это даже необходимо.

### R файл

Наиболее часто используемый файл из generatedJava -- это **R-файл**. R-файл это Java класс с именем `R` в Java пакете, имя которого указано в манифесте приложения в атрибуте `package` элемента `manifest`. В этом файле определены константы с  идентификаторами всех ресурсов приложения, которые используются для доступа к ресурсам. Например, в `HelloWorldActivity` мы писали такой код:
```
setContentView(R.layout.activity_hello_world);
```
А вот как выглядит определение константы `activity_hello_world` в R-файле (код других констант опущен):
```
package ru.ok.technopolis.helloworld;

public final class R {
    public static final class layout {
    	public static final int activity_hello_world=0x7f09001e;
    }
}
```
<img src="img/0630_r_file.png" width="1200px"/>

Значения констант в R файле могут меняться от сборки к сборке, поэтому на конкретные значения никогда нельзя полагаться, зато можно считать, что они все уникальные -- это гарантировано в рамках одного приложения.

### BuildConfig файл

Второй полезный файл из generateJava -- это класс **BuildConfig**. В нем определены константы с информацией о сборке приложения, взятые из `build.gradle` во время сборки.

Так выглядит `BuildConfig` для дебажной сборки в `app/build/generated/source/buildConfig/debug/`:
<img src="img/0640_build_config_debug.png" width="800px"/>
А так -- `BuildConfig` для релизной сборки в `app/build/generated/source/buildConfig/release/`:
<img src="img/0650_build_config_release.png" width="800px"/>

Константа `DEBUG` полезна для того, чтобы в коде выполнять разные действия в релизной или дебажной сборке: например, в случае непредвиденной ситуации в дебаге можно бросить исключение, чтобы обнаружить эту ситуацию как можно раньше на этапе разработки, а в релизной версии бросать исключение нельзя (чтобы не расстраивать пользователя) -- лучше тихо отправить логи в сервис сбора аналитики:
```
if (что-то неправильное случилось) {
	if (BuildConfig.DEBUG) {
    	throw new RuntimeException("Передайте Пете из команды Васи, что его API не работает, как он обещал");
    } else {
    	Crashlytics.log(Log.ERROR, "API", "Unexpected data format returned from API user.getFriends: " + data);
        // TODO: сообщить пользователю об ошибке или можно забить?
    }
}
```

В `BuildConfog` можно добавлять свои собственные константы. Для этого нужно добавить определение константы в `build.gradle`:
```
android {
	defaultConfig {
    	buildConfigField "boolean", "FEATURE_X_ENABLED", "true"
    }
    buildTypes {
    	release {
        	buildConfigField "int", "MAX_VCALL_PARTICIPANTS", "100"
            buildConfigField "String", "PORTAL_ADDRESS", '"https://www.portal.info"'
        }
        debug {
        	buildConfigField "int", "MAX_VCALL_PARTICIPANTS", "3"
            buildConfigField "String", "PORTAL_ADDRESS", '"http://127.0.0.1:4000"'
        }
    }
}
```

## Лишние файлы
## Логирование и BuildConfig файл
## Падение приложения
## Отладка дебаггером
## Сборка проекта из командной строки -- Gradle
## Запуск приложения из командной строки -- ADB

